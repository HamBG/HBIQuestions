## 基本概念

* **栈区（Stack）**：由编译器自动分配释放 ，存放函数的参数值，局部变量等，内存的分配是连续的，类似于数据结构中的栈。即，所分配的内存是在一块连续的内存区域内．当我们声明变量时，那么编译器会自动接着当前栈区的结尾来分配内存
* **堆区（Heap）**：一般由程序员分配释放， 若程序员不释放，程序结束时可能由操作系统回收．类似于链表，在内存中的分布不是连续的，它们是不同区域的内存块通过指针链接起来的．一旦某一节点从链中断开，我们要人为的把所断开的节点从内存中释放
* **全局/静态区（Static）**：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放
* **文字常量区**：常量字符串就是放在这里的。 程序结束后由系统释放
* **程序代码区**：存放函数体的二进制代码
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
* **静态分配**：程序编译链接时分配的大小和使用寿命就已经确定
* **动态分配**：在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不像数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。
* **内存泄露**：通常是程序自身编码缺陷造成。用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。
* **内存碎片**：是一个系统问题。描述系统中不可以用的空闲内存。由于空闲内存以小且不连续方式出现在不同的位置，导致空闲内存无法使用，这个与内存管理算法息息相关。
* **内部碎片**：已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；
* **内部碎片产生原因**：因为所有的内存分配必须起始于可被 4、8 或 16 整除（视处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法仅能把预定大小的内存块分配给客户。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。
* **外部碎片**：指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
* **外部碎片产生原因**：频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。如果一个进程申请了一个8个单位的内存空间，随后便释放了。后续进程申请的内存空间都大于8（比如是16，32等）。那么这8个单位的空间永远得不到使用，变成外部碎片。

##  理解到底放哪里

	int a = 0; //全局初始化区
    char *p1; //全局未初始化区
    main(){
         int b; //栈
         char s[] = "abc"; //栈
         char *p2; //栈
         char *p3 = "123456"; //123456\0在常量区，p3在栈上。
         static int c =0； //全局（静态）初始化区
         p1 = (char *)malloc(10); //堆
         p2 = (char *)malloc(20);  //堆
    }

## 堆内存与栈内存的区别

* **申请和回收方式不同**：栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。
* **碎片问题**：对于栈，不会产生不连续的内存块；但是对于堆来说，不断的new、delete势必会产生上面所述的内部碎片和外部碎片。
* **申请大小的限制**：栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间，就会产生栈溢出；对于堆，是向高地址扩展的数据结构，是不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
* ** 申请效率的比较**：栈由系统自动分配，速度较快。但程序员是无法控制的；堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。
* ** 当然还有存储内容的不一样**

>【文章来源简书:[Martin_wjl](http://www.jianshu.com/p/cbcf3ab0a8ba) ,转载请注明出处】