#贪心算法
对于问题的求解时，总是作出当前看来最好的选择。通常用来解决具有最大值和最小值的优化问题。
####实例：
假设有**4**种面值的钱币：２角、１角、**5**分和１分。要找给某顾客**5**角**3**分钱。根据贪心算法每次为了得到局部最优解，结果为：拿出**2**个**2**角，**1**个**1**角和**3**个**1**分的钱币
####性质：
1.  是做出局部最优解，这个结果往往不是整体最优解。
如果硬币面值为**1**角**1**分、**7**分、**5**分、和**1**分。要找给顾客**2**角**6**分钱， 按贪心方法找出的硬币个数是：**2**个**1**角**1**分和四个**1**分，共**6**枚，这比**1**个**1**角**1**分和**3**个**5**分多了**2**枚；因此，从局部的最优选择得到的解并不总是问题的最优解。 
2. 最优子结构性质，整体最优解包含局部最优解。这是动态规划和贪心算法的共同特征。
3. 贪心选择性质，希望通过一系列的局部最优解得到整体最优解。动态规划往往需要考虑前前后后，采取自底向上的形式来获取最优解，并且得到的总是最优解；贪心算法仅在当前状态下作出最好选择，即局部最优选择，但不依赖于子问题的解，采取自顶向下的形式，往往得到的解只是接近最优解（有些情况是最优解）。

#背包问题

![题目](http://upload-images.jianshu.io/upload_images/852671-0b2cc48bc923bc9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
针对题目，要找到**贪婪准则**很重要，量度标准可以是物品价值、单位重量价值等。这里明显是单位重量价值更为合适。
####代码实现
	
	    #include <iostream>
	    void knapsack(int n, float M, float v[], float w[], float x[]);
	
	    int main(int argc, const char * argv[]){
	    
		    float v[] = {24,15,25};
		    float w[] = {15,10,18};
		    float M = 20;
		    float x[4] = {0,0,0};
		    
		    knapsack(3, M, v, w, x);
		    
		    for(int i=1; i<=3; i++)
		    {
		        std::cout<<"["<<i<<"]:"<<x[i]<<std::endl;
		    }
		    
		    
		    return 0;
		    
	    }
	
	    void knapsack(int n, float M, float v[], float w[], float x[]){
	    
			    //单位重量价值排序
			    //sort(n,v,w)
			    
			    int i ;
			    //背包剩余容量
			    float c = M;
		
		    for (i=1; i<=n; i++) {
		        
		        if (w[i]>c) {
		            break;
		        }
		        x[i] = 1;
		        c = c - w[i];
		        
		    }
		    if (i<=n) {
		        x[i] = c/w[i];
		    }
	    
	    }
#### 复杂度分析
算法knapsack的主要计算时间在于将各种物品依其单位重量的价值从大到小排序。因此，算法的计算时间上界为O(nlogn)